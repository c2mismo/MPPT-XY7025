Estudiar si es posible implementar en un arduino mas pequeño que un arduino UNO, sino utilizar un ESP32.

Necesita tres comunicaciones UARTs:
1.- Debug
2.- UART - RS485 para comunicación con XY7025
Cualquier pin excepto el 0 y 1 Debug & i2c A4 y A5 & SPI MOSI 11, MISO 12 y SCK 13
3.- UART - RS485 para comunicación con otros dispositivos
Cualquier pin excepto el 0 y 1 Debug & i2c A4 y A5 & SPI MOSI 11, MISO 12 y SCK 13






Un módulo reloj de precision ejemplo DS3231

Pines principales del módulo DS3231 (módulo típico con breakout):
el DS3231 usa normalmente la dirección 0x68


VCC: Alimentación (generalmente 3.3V o 5V).
PIN 5V

GND: Conexión a tierra.
PIN GND

SCL: Línea de reloj del bus I²C.
    En Arduino UNO, este pin se conecta al pin A5 (o al pin marcado como SCL en placas R3)
PIN A5

SDA: Línea de datos del bus I²C.
		En Arduino UNO, este pin se conecta al pin A4 (o al pin marcado como SDA en placas R3)
PIN A4

SQW / INT: Cualquier pin digital
PIN DIO

32K: Salida de señal de reloj de 32.768 kHz
No CN




Un módulo ADS1115 interfaz I2C con comparador integrado
el ADS1115 usa normalmente la dirección 0x48 por defecto si no hay conflicto

VDD → Alimentación (puedes conectar a 5V o 3.3V; el chip acepta de 2.0V a 5.5V)
PIN 5V

GND → Tierra
PIN GND

SCL: Línea de reloj del bus I²C.
    En Arduino UNO, este pin se conecta al pin A5 (o al pin marcado como SCL en placas R3)
PIN A5

SDA: Línea de datos del bus I²C.
		En Arduino UNO, este pin se conecta al pin A4 (o al pin marcado como SDA en placas R3)
PIN A4

ALERT/RDY:
    Es una salida programable que puede indicar cuando una conversión ha terminado o cuando una señal supera un umbral (comparador interno).
    Si lo usas, conéctalo a cualquier pin digital del Arduino
No CN

ADDR → Pin para seleccionar la dirección I²C del dispositivo .
    ✅ Importante: El ADS1115 permite hasta 4 direcciones I²C diferentes, cambiando cómo se conecta el pin ADDR:
        ADDR a GND → dirección 0x48 (la más común)
        ADDR a VDD → 0x49
        ADDR a SDA → 0x4A
        ADDR a SCL → 0x4B
Uses resistencias de pull-up en SDA/SCL (muchos módulos las incluyen; si no, añade 4.7 kΩ a 5V en ambos pines).





Un módulo adaptador tarjeta MicroSD SPI para guardar los registros

3v3: Alimentación
PIN 3v3

GND: Tierra
PIN GND

CS: Chip Select (activo en bajo)
PIN 10

MOSI: Master Out Slave In
PIN 11

MISO: Master In Slave Out
PIN 12

SCK. Clock SPI
PIN 13






Sensor temperatura DS18B20
El DS18B20 usa el protocolo 1-Wire, que requiere solo un pin de datos (más VCC y GND).

Modo normal (con resistencia pull-up):

DATA: Usa una resistencia de 4.7 kΩ entre DATA y VCC
PIN cualquier D2~D9










Crear una libreria XY7025.h
Usando la libreria ModbusMaster.h Fnt. https://github.com/4-20ma/ModbusMaster

La libreria debe de poder trabajar con varios MPPT
Para construir la libreria habrá que indicar los pines que se van a utilizar
para comunicacion

Por lo pronto cuatros funciones:

1.- Leer un registro concreto.


1.- Leer Registros Criticos.
Todos esos registros dignos de ser guardados en un documento para poder analizar rendimientos

2.- Leer todos los registros.

3.- Enviar valor nuevo para cualquier registro escribible.
debe verificar la correcta escritura, para eso reservamos una variable
(bool envioCorrecto = 0;) que en un inicio debe ser low
envia el dato al MPPT
solicita al MPPT de nuevo el dato
verifica si es correcto
si el dato devuelto es el correcto (envioCorrecto = 1;)

4.- Enviar valores para una configuración preestablecida para baterias LFPO


*.- Monitoreo continuo de PROTECT:
Verificar este registro cada 5-10 segundos


if(decodificarProteccion(estado) == "SOBRETEMP_INTERNA") {
  reducirCarga(50);  // Disminuir potencia al 50%
  activarVentiladores();
}




Debe comunicarse con mas de un dispositivo XY7025






#include <ModbusMaster.h>

// Definir número máximo de dispositivos Modbus
#define MAX_DEVICES 10

// Array de objetos ModbusMaster, uno por cada posible unidad Modbus
ModbusMaster node[MAX_DEVICES];

// Registro de protección de sobretensión
const uint16_t S_OVP = 0x0052;
const uint16_t S_INI = 0x005D;

void setup() {
  Serial.begin(115200);
  Serial2.begin(115200);  // Puerto Serie para RS485

  // Inicializar cada nodo con su ID Modbus
  // Supongamos que tus dispositivos tienen IDs: 1, 2, 3, etc.
  for (int i = 1; i <= 3; i++) {  // Ajusta según cuántos dispositivos tengas
    node[i].begin(i, Serial2);
  }

  // Configurar protección básica en MPPT ID=1
  writeRegister(1, S_OVP, 1450);  // S-OVP = 14.50V
  writeRegister(1, S_INI, 1);     // S-INI = Salida ON al arrancar

  // Si quisieras escribir en otro MPPT, por ejemplo ID=2
  // writeRegister(2, S_OVP, 1460);  // Diferente valor para otro dispositivo
}

// Escribir registro (función 0x06) a una unidad Modbus específica
void writeRegister(uint8_t unidad, uint16_t reg, uint16_t value) {
  node[unidad].writeSingleRegister(reg, value);
}

void loop() {
  // Aquí puedes leer o escribir según necesites
  delay(1000);
}









